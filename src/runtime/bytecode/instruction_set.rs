use anyhow::{anyhow, Result};

#[derive(Debug)]
#[allow(non_camel_case_types, clippy::upper_case_acronyms)]
pub enum Instruction {
    AALOAD,
    AASTORE,
    ACONST_NULL,
    ALOAD,
    ALOAD_0,
    ALOAD_1,
    ALOAD_2,
    ALOAD_3,
    ANEWARRAY,
    ARETURN,
    ARRAYLENGTH,
    ASTORE,
    ASTORE_0,
    ASTORE_1,
    ASTORE_2,
    ASTORE_3,
    ATHROW,
    BALOAD,
    BASTORE,
    BIPUSH,
    CALOAD,
    CASTORE,
    CHECKCAST,
    D2F,
    D2I,
    D2L,
    DADD,
    DALOAD,
    DASTORE,
    DCMPG,
    DCMPL,
    DCONST_0,
    DCONST_1,
    DDIV,
    DLOAD,
    DLOAD_0,
    DLOAD_1,
    DLOAD_2,
    DLOAD_3,
    DMUL,
    DNEG,
    DREM,
    DRETURN,
    DSTORE,
    DSTORE_0,
    DSTORE_1,
    DSTORE_2,
    DSTORE_3,
    DSUB,
    DUP,
    DUP_X1,
    DUP_X2,
    DUP2,
    DUP2_X1,
    DUP2_X3,
    F2D,
    F2I,
    F2L,
    FADD,
    FALOAD,
    FASTORE,
    FCMPG,
    FCMPL,
    FCONST_0,
    FCONST_1,
    FCONST_2,
    FDIV,
    FLOAD,
    FLOAD_0,
    FLOAD_1,
    FLOAD_2,
    FLOAD_3,
    FMUL,
    FNEG,
    FREM,
    FRETURN,
    FSTORE,
    FSTORE_0,
    FSTORE_1,
    FSTORE_2,
    FSTORE_3,
    FSUB,
    GETFIELD,
    GETSTATIC,
    GOTO,
    GOTO_W,
    I2B,
    I2C,
    I2D,
    I2F,
    I2L,
    I2S,
    IADD,
    IALOAD,
    IAND,
    IASTORE,
    ICONST_M1,
    ICONST_0,
    ICONST_1,
    ICONST_2,
    ICONST_3,
    ICONST_4,
    ICONST_5,
    IDIV,
    IF_ACMPEQ,
    IF_ACMPNE,
    IF_ICMPEQ,
    IF_ICMPNE,
    IF_ICMPLT,
    IF_ICMPGT,
    IF_ICMPLE,
    IFEQ,
    IFNE,
    IFLT,
    IFGE,
    IFGT,
    IFLE,
    IFNOTNULL,
    IFNULL,
    IINC,
    ILOAD,
    ILOAD_0,
    ILOAD_1,
    ILOAD_2,
    ILOAD_3,
    IMUL,
    INEG,
    INSTANCEOF,
    INVOKEDYNAMIC,
    INVOKEINTERFACE,
    INVOKESPECIAL,
    INVOKESTATIC,
    INVOKEVIRTUAL,
    IOR,
    IREM,
    IRETURN,
    ISHL,
    ISHR,
    ISTORE,
    ISTORE_0,
    ISTORE_1,
    ISTORE_2,
    ISTORE_3,
    ISUB,
    IUSHR,
    IXOR,
    JSR,
    JSR_W,
    L2D,
    L2F,
    L2I,
    LADD,
    LALOAD,
    LAND,
    LASTORE,
    LCMP,
    LCONST_0,
    LCONST_1,
    LDC,
    LDC_W,
    LDC2_W,
    LDIV,
    LLOAD,
    LLOAD_0,
    LLOAD_1,
    LLOAD_2,
    LLOAD_3,
    LMUL,
    LNEG,
    LOOKUPSWITCH,
    LOR,
    LREM,
    LRETURN,
    LSHL,
    LSHR,
    LSTORE,
    LSTORE_0,
    LSTORE_1,
    LSTORE_2,
    LSTORE_3,
    LSUB,
    LUSHR,
    LXOR,
    MONITORENTER,
    MONITOREXIT,
    MULTIANEWARRAY,
    NEW,
    NEWARRAY,
    NOP,
    POP,
    POP2,
    PUTFIELD,
    PUTSTATIC,
    RET,
    RETURN,
    SALOAD,
    SASTORE,
    SIPUSH,
    SWAP,
    TABLESWTICH,
    WIDE,
}

impl Instruction {
    pub fn from_byte(byte: u8) -> Result<Instruction> {
        Ok(match byte {
            0xBB => Instruction::NEW,
            0x12 => Instruction::LDC,
            0xB2 => Instruction::GETSTATIC,
            0xB6 => Instruction::INVOKEVIRTUAL,
            0x2A => Instruction::ALOAD_0,
            0x2B => Instruction::ALOAD_1,
            0x2C => Instruction::ALOAD_2,
            0x2D => Instruction::ALOAD_3,
            0x19 => Instruction::ALOAD,
            0x3 => Instruction::ICONST_0,
            0x4 => Instruction::ICONST_1,
            0xB8 => Instruction::INVOKESTATIC,
            0x1 => Instruction::ACONST_NULL,
            0xB3 => Instruction::PUTSTATIC,
            0xB1 => Instruction::RETURN,
            0x59 => Instruction::DUP,
            0xB7 => Instruction::INVOKESPECIAL,
            0xB0 => Instruction::ARETURN,
            0x1A => Instruction::ILOAD_0,
            0x1B => Instruction::ILOAD_1,
            0x1C => Instruction::ILOAD_2,
            0x1D => Instruction::ILOAD_3,
            0x15 => Instruction::ILOAD,
            0x4B => Instruction::ASTORE_0,
            0x4C => Instruction::ASTORE_1,
            0x4D => Instruction::ASTORE_2,
            0x4E => Instruction::ASTORE_3,
            0x3A => Instruction::ASTORE,
            0xC6 => Instruction::IFNULL,
            0x10 => Instruction::BIPUSH,
            _ => return Err(anyhow!("unknown instruction 0x{:X}", byte)),
        })
    }
}
